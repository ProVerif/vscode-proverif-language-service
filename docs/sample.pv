type key2_t.
type key_t [private].

fun convert(key_t): key2_t.
fun reverse(key2_t): key_t
	reduc forall key:key_t; 
		reverse(convert(key)) = key [private].

reduc forall key: key_t; let g = convert(key) in convert2(g) = true.
equation forall key: key_t; let g = convert(key) in true.

const key_c: key_t.
const key_c2: key_t[private].
free key_f: key_t.
free key_f2: key_t[private].

event Confirmed.
event Confirmed2(key_t).
event ConfirmedPriv(key_t)[solveOnce].

pred pConfirmed.
pred pConfirmed2(key_t).
pred pConfirmedPriv(key_t)[solveOnce].

channel public.
channel public2.

letfun no_conversion(key: key_t) = key. 
let publish(key: key_t or fail) = out(public, key). 

set attacker = passive.
set reconstructTrace = 2.
set privateCommOnPublicTerms = false.

select key:key_t; let key2 = convert(key2) in mess(cell_tally( *e_id), *x) phase 2 / 8000 [ignoreAFewTimes].
noselect key:key_t; let key2 = convert(key2) in mess(cell_tally( *e_id), *x) / 8000 [ignoreAFewTimes].
nounif x:bitstring; mess(new cprivR1,*x) [ignoreAFewTimes].

process
0